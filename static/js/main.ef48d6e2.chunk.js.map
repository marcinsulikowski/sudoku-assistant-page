{"version":3,"sources":["index.js","SudokuModel.js"],"names":["SudokuModel","require","default","Cell","cornerMarks","Array","fill","cornerIndex","value","this","props","cell","length","centerMarks","className","classNames","color","fixed","selected","incorrect","getClassName","onClick","React","Component","Board","key","boxes","boxRow","boxCol","cells","cellRow","cellCol","row","column","push","sudoku","getCell","event","handleClick","Game","state","clone","ctrlKey","deselectAll","toggleSelection","setState","handleKey","keyWithModifiers","keyboardEvent","name","metaKey","altKey","shiftKey","getKeyWithModifiers","handleUndo","handleRedo","mode","test","number","charCodeAt","setValueInSelectedCells","runHelpers","helpers","pushToUndoList","toggleCenterInSelectedCells","toggleCornerInSelectedCells","setColorInSelectedCells","clearValueInSelectedCells","selectedColor","moveSelection","handleSetMode","handleLoad","savedPuzzle","clipboardData","getData","loadPuzzle","handleSave","saveTextArea","current","savePuzzle","style","display","select","document","execCommand","historyPosition","history","handleClear","emptySudoku","handleRestart","restart","handleHelperFlagChange","createRef","removeInvalidMarks","addCenterMarks","addCornerMarks","fillOnSingleCenterMark","fillOnSingleCornerMark","slice","window","addEventListener","removeEventListener","renderModeButton","shortcut","modeUpper","charAt","toUpperCase","isSelected","renderColorButton","colorId","renderHelperFlag","flagName","description","type","checked","onChange","onPaste","ref","ReactDOM","render","getElementById","bitmaskCount","valueBitmask","trueCount","bitmaskAndInPlace","valueBitmask1","valueBitmask2","bitmaskOrInPlace","lastSelected","index","possibleValues","cloned","Object","assign","create","getPrototypeOf","JSON","parse","stringify","values","getAllCells","join","puzzle","filter","concat","boxColumn","rowInBox","columnInBox","getBoxCells","regions","getAllBoxes","getRowCells","getColumnCells","rowDiff","columnDiff","Math","max","min","getSelectedCells","valuesAdded","updateIncorrect","updatePossibleValues","clearImpossibleMarks","autofillCenterMarks","autofillCornerMarks","autofillValuesOnSingleCenterMarks","autofillValuesOnSingleCornerMarks","hasIncorrectCells","getAllRegions","region","counts","possibleInRegion","box","alreadyMarkedValues","possibleCellsForValue","changed","indexOf","alreadyFilledValues","targetCells"],"mappings":"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","file":"static/js/main.ef48d6e2.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nconst SudokuModel = require('./SudokuModel').default;\n\nfunction getKeyWithModifiers(keyboardEvent) {\n  let name = keyboardEvent.key;\n  if (keyboardEvent.metaKey) {\n    name = \"Meta-\" + name;\n  }\n  if (keyboardEvent.altKey) {\n    name = \"Atl-\" + name;\n  }\n  if (keyboardEvent.ctrlKey) {\n    name = \"Control-\" + name;\n  }\n  if (keyboardEvent.shiftKey) {\n    name = \"Shift-\" + name;\n  }\n  return name;\n}\n\nclass Cell extends React.Component {\n  render() {\n    let getClassName = () => {\n      let classNames = \"cell\";\n      if (this.props.cell.color !== null) {\n        classNames += ` color${this.props.cell.color}`;\n      }\n      if (!this.props.cell.fixed) {\n        classNames += \" variable\";\n      }\n      if (this.props.cell.selected) {\n        classNames += \" selected\";\n      }\n      if (this.props.cell.incorrect) {\n        classNames += \" incorrect\";\n      }\n      if (this.props.cell.value !== null) {\n        classNames += \" disable-pencil-marks\"\n      }\n      return classNames;\n    }\n\n    let cornerMarks = Array(6).fill(\"\");\n    let cornerIndex = 0;\n    for (let value = 1; value <= 9; ++value) {\n      if (this.props.cell.cornerMarks[value]) {\n        cornerMarks[cornerIndex] += value;\n        if (++cornerIndex === cornerMarks.length) {\n          break;\n        }\n      }\n    }\n\n    let centerMarks = \"\";\n    for (let value = 1; value <= 9; ++value) {\n      if (this.props.cell.centerMarks[value]) {\n        centerMarks += value;\n      }\n    }\n\n    return (\n      <div\n        className={getClassName()}\n        onClick={this.props.onClick}\n      >\n        <div className=\"pencil-marks\">\n          <div className=\"pencil-mark corner top-l\">{cornerMarks[0]}</div>\n          <div className=\"pencil-mark corner top-r\">{cornerMarks[1]}</div>\n          <div className=\"pencil-mark corner bottom-l\">{cornerMarks[2]}</div>\n          <div className=\"pencil-mark corner bottom-r\">{cornerMarks[3]}</div>\n          <div className=\"pencil-mark corner top-c\">{cornerMarks[4]}</div>\n          <div className=\"pencil-mark corner bottom-c\">{cornerMarks[5]}</div>\n          <div className=\"pencil-mark central\">{centerMarks}</div>\n        </div>\n        {this.props.cell.value}\n      </div>\n    );\n  }\n}\n\nclass Board extends React.Component {\n  render() {\n    let key = 0;\n    let boxes = [];\n    for (let boxRow = 0; boxRow < 3; ++boxRow) {\n      for (let boxCol = 0; boxCol < 3; ++boxCol) {\n        let cells = [];\n        for (let cellRow = 0; cellRow < 3; ++cellRow) {\n          for (let cellCol = 0; cellCol < 3; ++cellCol) {\n            let row = 3 * boxRow + cellRow;\n            let column = 3 * boxCol + cellCol;\n            cells.push(\n              <Cell\n                key={++key}\n                cell={this.props.sudoku.getCell(row, column)}\n                onClick={\n                  (event) => this.props.handleClick(event, row, column)\n                }\n              />\n            );\n          }\n        }\n        boxes.push(<div className=\"box\" key={++key}>{cells}</div>);\n      }\n    }\n    return (<div className=\"board\">{boxes}</div>);\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.saveTextArea = React.createRef();\n    this.state = {\n      mode: \"normal\",\n      selectedColor: 0,\n      sudoku: new SudokuModel(),\n      helpers: {\n        removeInvalidMarks: true,\n        addCenterMarks: true,\n        addCornerMarks: true,\n        fillOnSingleCenterMark: true,\n        fillOnSingleCornerMark: true,\n      }\n    };\n    this.history = [this.state.sudoku];\n    this.historyPosition = 0;\n  }\n\n  pushToUndoList(sudoku) {\n    if (this.historyPosition < this.history.length - 1) {\n      this.history = this.history.slice(0, this.historyPosition + 1);\n    }\n    this.history.push(sudoku);\n    this.historyPosition++;\n  }\n\n  // Event handlers\n\n  handleClick = (event, row, column) => {\n    // Ctrl+click adds a new field to the selection. Without Ctrl,\n    // we deselect all the fields and select only the clicked one.\n    let sudoku = this.state.sudoku.clone();\n    if (!event.ctrlKey) {\n      sudoku.deselectAll();\n    }\n    sudoku.toggleSelection(row, column);\n    this.setState({sudoku: sudoku});\n  }\n\n  handleKey = (event) => {\n    let keyWithModifiers = getKeyWithModifiers(event);\n\n    // Shortcuts handled by delegating to other event handlers.\n    if (keyWithModifiers === \"Control-z\") {\n      return this.handleUndo();\n    } else if (keyWithModifiers === \"Control-y\") {\n      return this.handleRedo();\n    }\n\n    // Shortcuts which don't modify the state of sudoku\n    if (keyWithModifiers === \" \") {\n      return this.setState((state) => {\n        switch (state.mode) {\n          case \"normal\": return {mode: \"center\"};\n          case \"center\": return {mode: \"corner\"};\n          case \"corner\": return {mode: \"color\"};\n          default:       return {mode: \"normal\"};\n        }\n      });\n    } else if (keyWithModifiers === \"a\") {\n      return this.setState({mode: \"normal\"});\n    } else if (keyWithModifiers === \"z\") {\n      return this.setState({mode: \"center\"});\n    } else if (keyWithModifiers === \"x\") {\n      return this.setState({mode: \"corner\"});\n    } else if (keyWithModifiers === \"c\") {\n      return this.setState({mode: \"color\"});\n    }\n\n    // Shortcuts which modify the sudoku.\n    let sudoku = this.state.sudoku.clone();\n    if (/^[1-9]$/.test(keyWithModifiers)) {\n      let number = keyWithModifiers.charCodeAt(0) - \"0\".charCodeAt(0);\n      if (this.state.mode === \"normal\") {\n        sudoku.setValueInSelectedCells(number);\n        sudoku.runHelpers(this.state.helpers);\n        this.pushToUndoList(sudoku);\n      } else if (this.state.mode === \"center\") {\n        sudoku.toggleCenterInSelectedCells(number);\n        this.pushToUndoList(sudoku);\n      } else if (this.state.mode === \"corner\") {\n        sudoku.toggleCornerInSelectedCells(number);\n        this.pushToUndoList(sudoku);\n      }\n    } else if (keyWithModifiers === \"Delete\") {\n      if (this.state.mode === \"color\") {\n        sudoku.setColorInSelectedCells(null);\n        this.pushToUndoList(sudoku);\n      } else {\n        sudoku.clearValueInSelectedCells();\n        sudoku.runHelpers(this.state.helpers);\n        this.pushToUndoList(sudoku);\n      }\n    } else if (keyWithModifiers === \"Enter\") {\n      if (this.state.mode === \"color\") {\n        sudoku.setColorInSelectedCells(this.state.selectedColor);\n        this.pushToUndoList(sudoku);\n      }\n    } else if (keyWithModifiers === \"ArrowLeft\") {\n      sudoku.moveSelection(0, -1);\n    } else if (keyWithModifiers === \"ArrowRight\") {\n      sudoku.moveSelection(0, +1);\n    } else if (keyWithModifiers === \"ArrowUp\") {\n      sudoku.moveSelection(-1, 0);\n    } else if (keyWithModifiers === \"ArrowDown\") {\n      sudoku.moveSelection(+1, 0);\n    }\n    this.setState({sudoku: sudoku});\n  }\n\n  handleSetMode = (mode, color) => {\n    this.setState({mode: mode});\n    if (color !== null) {\n      this.setState({selectedColor: color});\n    }\n  }\n\n  handleLoad = (event) => {\n    let savedPuzzle = event.clipboardData.getData(\"Text\");\n    let sudoku = this.state.sudoku.clone();\n    sudoku.loadPuzzle(savedPuzzle);\n    sudoku.runHelpers(this.state.helpers);\n    this.pushToUndoList(sudoku);\n    this.setState({sudoku: sudoku});\n  }\n\n  handleSave = () => {\n    this.saveTextArea.current.value = this.state.sudoku.savePuzzle();\n    this.saveTextArea.current.style.display = \"block\";\n    this.saveTextArea.current.select();\n    document.execCommand(\"copy\");\n    this.saveTextArea.current.style.display = \"none\";\n  }\n\n  handleUndo = () => {\n    if (this.historyPosition > 0) {\n      this.setState({sudoku: this.history[--this.historyPosition]});\n    }\n  }\n\n  handleRedo = () => {\n    if (this.historyPosition < this.history.length - 1) {\n      this.setState({sudoku: this.history[++this.historyPosition]});\n    }\n  }\n\n  handleClear = () => {\n    let emptySudoku = new SudokuModel();\n    this.pushToUndoList(emptySudoku);\n    this.setState({sudoku: emptySudoku});\n  }\n\n  handleRestart = () => {\n    let sudoku = this.state.sudoku.clone();\n    sudoku.restart();\n    sudoku.runHelpers(this.state.helpers);\n    this.pushToUndoList(sudoku);\n    this.setState({sudoku: sudoku});\n  }\n\n  handleHelperFlagChange = (name) => {\n    this.setState((state) => {\n      let helpers = {\n        ...state.helpers,\n        [name]: !state.helpers[name]\n      }\n      let sudoku = state.sudoku.clone();\n      sudoku.runHelpers(helpers);\n      this.pushToUndoList(sudoku);\n      return {\n        sudoku: sudoku,\n        helpers: helpers,\n      };\n    });\n  }\n\n  // ReactJS stuff\n\n  componentDidMount() {\n    window.addEventListener(\"keydown\", this.handleKey);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.handleKey);\n  }\n\n  render() {\n    let renderModeButton = (mode, shortcut) => {\n      let modeUpper = mode.charAt(0).toUpperCase() + mode.slice(1);\n      let isSelected = this.state.mode === mode;\n      return (\n        <button\n          className={\"mode \" + (isSelected ? \"selected\" : \"\")}\n          onClick={() => this.handleSetMode(mode, null)}\n        >\n          {`${modeUpper} (${shortcut})`}\n        </button>\n      );\n    }\n\n    let renderColorButton = (colorId) => {\n      let isSelected = (this.state.mode === \"color\"\n                        && this.state.selectedColor === colorId)\n      return (\n        <button\n          className={\"color \" + (isSelected ? \"selected\" : \"\")}\n          onClick={() => this.handleSetMode(\"color\", colorId)}\n        >\n          <div className={`sample color${colorId}`}></div>\n        </button>\n      );\n    }\n\n    let renderHelperFlag = (flagName, description) => {\n      return (\n        <div className=\"helper-flag\">\n          <input\n            type=\"checkbox\"\n            checked={this.state.helpers[flagName]}\n            onChange={(event) => this.handleHelperFlagChange(flagName)}\n          />\n          <label>{description}</label>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"game\" onPaste={this.handleLoad}>\n        <Board\n          sudoku={this.state.sudoku}\n          handleClick={this.handleClick}\n        />\n        <div className=\"panel\">\n          <div className=\"controls\">\n            {renderModeButton(\"normal\", \"A\")}\n            {renderModeButton(\"center\", \"Z\")}\n            {renderModeButton(\"corner\", \"X\")}\n            {renderColorButton(0)}\n            {renderColorButton(1)}\n            {renderColorButton(2)}\n            {renderColorButton(3)}\n            {renderColorButton(4)}\n            {renderColorButton(5)}\n            {renderColorButton(6)}\n            {renderColorButton(7)}\n            {renderColorButton(8)}\n            <button onClick={this.handleUndo}>Undo</button>\n            <button onClick={this.handleRedo}>Redo</button>\n            <button onClick={this.handleSave}>Copy to clipboard</button>\n            <button onClick={this.handleClear}>Clear board</button>\n            <button onClick={this.handleRestart}>Restart</button>\n            {renderHelperFlag(\n              \"removeInvalidMarks\",\n              \"Remove invalid marks\"\n            )}\n            {renderHelperFlag(\n              \"addCenterMarks\",\n              \"Automatically add center marks\"\n            )}\n            {renderHelperFlag(\n              \"addCornerMarks\",\n              \"Automatically add corner marks\"\n            )}\n            {renderHelperFlag(\n              \"fillOnSingleCenterMark\",\n              \"Automatically fill values based on center marks\"\n            )}\n            {renderHelperFlag(\n              \"fillOnSingleCornerMark\",\n              \"Automatically fill values based on corner marks\"\n            )}\n          </div>\n          <textarea className=\"save\" ref={this.saveTextArea}></textarea>\n        </div>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n","function bitmaskCount(valueBitmask) {\n  let trueCount = 0;\n  for (let value = 1; value <= 9; ++value) {\n    if (valueBitmask[value]) {\n      trueCount++;\n    }\n  }\n  return trueCount;\n}\n\n\nfunction bitmaskAndInPlace(valueBitmask1, valueBitmask2) {\n  for (let value = 1; value <= 9; ++value) {\n    valueBitmask1[value] = (valueBitmask1[value] && valueBitmask2[value]);\n  }\n}\n\n\nfunction bitmaskOrInPlace(valueBitmask1, valueBitmask2) {\n  for (let value = 1; value <= 9; ++value) {\n    valueBitmask1[value] = (valueBitmask1[value] || valueBitmask2[value]);\n  }\n}\n\n\nclass SudokuModel {\n  constructor() {\n    this.lastSelected = {row: 0, column: 0};\n    this.cells = Array(9);\n\n    for (let row = 0; row < 9; row++) {\n      this.cells[row] = Array(9);\n      for (let column = 0; column < 9; column++) {\n        this.cells[row][column] = {\n          row: row,\n          column: column,\n          index: row * 9 + column,\n          selected: false,\n          incorrect: false,\n          fixed: false,\n          value: null,\n          color: null,\n          centerMarks: Array(10).fill(false),\n          cornerMarks: Array(10).fill(false),\n          possibleValues: Array(10).fill(false),\n        }\n      }\n    }\n  }\n\n  clone() {\n    let cloned = Object.assign(\n      Object.create(Object.getPrototypeOf(this)),\n      this\n    );\n    cloned.lastSelected = JSON.parse(JSON.stringify(this.lastSelected));\n    cloned.cells = JSON.parse(JSON.stringify(this.cells));\n    return cloned;\n  }\n\n  savePuzzle() {\n    let values = Array(9 * 9).fill(0);\n    for (const cell of this.getAllCells()) {\n      values[cell.index] = (cell.value === null ? 0 : cell.value);\n    }\n    return values.join(\"\");\n  }\n\n  loadPuzzle(puzzle) {\n    for (const cell of this.getAllCells()) {\n      let value = puzzle.charCodeAt(cell.index) - \"0\".charCodeAt(0);\n      cell.value = (value === 0 ? null : value);\n      cell.color = null;\n      cell.fixed = (cell.value !== null);\n      cell.cornerMarks.fill(false);\n      cell.centerMarks.fill(false);\n    }\n  }\n\n  restart() {\n    for (const cell of this.getAllCells()) {\n      cell.color = null;\n      if (!cell.fixed) {\n        cell.value = null;\n        cell.cornerMarks.fill(false);\n        cell.centerMarks.fill(false);\n      }\n    }\n  }\n\n  getCell(row, column) {\n    return this.cells[row][column];\n  }\n\n  getSelectedCells() {\n    return this.getAllCells().filter((cell) => cell.selected);\n  }\n\n  getAllCells() {\n    let cells = [];\n    for (let row = 0; row < 9; ++row) {\n      cells = cells.concat(this.cells[row]);\n    }\n    return cells;\n  }\n\n  getRowCells(row) {\n    return this.cells[row];\n  }\n\n  getColumnCells(column) {\n    let cells = [];\n    for (let row = 0; row < 9; ++row) {\n      cells.push(this.cells[row][column]);\n    }\n    return cells;\n  }\n\n  getBoxCells(boxRow, boxColumn) {\n    let cells = [];\n    for (let rowInBox = 0; rowInBox < 3; ++rowInBox) {\n      for (let columnInBox = 0; columnInBox < 3; ++columnInBox) {\n        let row = 3 * boxRow + rowInBox;\n        let column = 3 * boxColumn + columnInBox;\n        cells.push(this.cells[row][column]);\n      }\n    }\n    return cells;\n  }\n\n  getAllBoxes() {\n    let boxes = [];\n    for (let boxRow = 0; boxRow < 3; boxRow++) {\n      for (let boxColumn = 0; boxColumn < 3; boxColumn++) {\n        boxes.push(this.getBoxCells(boxRow, boxColumn));\n      }\n    }\n    return boxes;\n  }\n\n  getAllRegions() {\n    let regions = this.getAllBoxes();\n    for (let row = 0; row < 9; row++) {\n      regions.push(this.getRowCells(row));\n    }\n    for (let column = 0; column < 9; column++) {\n      regions.push(this.getColumnCells(column));\n    }\n    return regions;\n  }\n\n  deselectAll() {\n    for (const cell of this.getAllCells()) {\n      cell.selected = false;\n    }\n  }\n\n  toggleSelection(row, column) {\n    let cell = this.getCell(row, column);\n    cell.selected = !cell.selected;\n    this.lastSelected = {row: row, column: column};\n  }\n\n  moveSelection(rowDiff, columnDiff) {\n    for (const cell of this.getAllCells()) {\n      cell.selected = false;\n    }\n    this.lastSelected.row = Math.max(\n      0,\n      Math.min(8, this.lastSelected.row + rowDiff)\n    );\n    this.lastSelected.column = Math.max(\n      0,\n      Math.min(8, this.lastSelected.column + columnDiff)\n    );\n    this.getCell(\n      this.lastSelected.row,\n      this.lastSelected.column\n    ).selected = true;\n  }\n\n  setValueInSelectedCells(value) {\n    for (const cell of this.getSelectedCells()) {\n      if (!cell.fixed) {\n        cell.value = value;\n      }\n    }\n  }\n\n  clearValueInSelectedCells() {\n    for (const cell of this.getSelectedCells()) {\n      if (cell.value === null) {\n        cell.centerMarks.fill(false);\n        cell.cornerMarks.fill(false);\n      } else if (!cell.fixed) {\n        cell.value = null;\n      }\n    }\n  }\n\n  toggleCenterInSelectedCells(value) {\n    for (const cell of this.getSelectedCells()) {\n      if (cell.value === null) {\n        cell.centerMarks[value] = !cell.centerMarks[value];\n      }\n    }\n  }\n\n  toggleCornerInSelectedCells(value) {\n    for (const cell of this.getSelectedCells()) {\n      if (cell.value === null) {\n        cell.cornerMarks[value] = !cell.cornerMarks[value];\n      }\n    }\n  }\n\n  setColorInSelectedCells(color) {\n    for (const cell of this.getSelectedCells()) {\n      cell.color = color;\n    }\n  }\n\n  runHelpers(helpers) {\n    let valuesAdded = false;\n    do {\n      if (this.updateIncorrect()) {\n        return;\n      }\n      this.updatePossibleValues();\n\n      if (helpers.removeInvalidMarks) {\n        this.clearImpossibleMarks();\n      }\n      if (helpers.addCenterMarks) {\n        this.autofillCenterMarks();\n      }\n      if (helpers.addCornerMarks) {\n        this.autofillCornerMarks();\n      }\n\n      valuesAdded = false;\n      if (helpers.fillOnSingleCenterMark) {\n        valuesAdded |= this.autofillValuesOnSingleCenterMarks();\n      }\n      if (helpers.fillOnSingleCornerMark) {\n        valuesAdded |= this.autofillValuesOnSingleCornerMarks();\n      }\n    } while (valuesAdded);\n  }\n\n  updateIncorrect() {\n    for (const cell of this.getAllCells()) {\n      cell.incorrect = false;\n    }\n\n    let hasIncorrectCells = false;\n    for (const region of this.getAllRegions()) {\n      let counts = Array(10).fill(0);\n      for (const cell of region) {\n        if (cell.value !== null) {\n          counts[cell.value]++;\n        }\n      }\n      for (const cell of region) {\n        if (cell.value !== null && counts[cell.value] > 1) {\n          cell.incorrect = true;\n          hasIncorrectCells = true;\n        }\n      }\n    }\n    return hasIncorrectCells;\n  }\n\n  updatePossibleValues() {\n    for (const cell of this.getAllCells()) {\n      cell.possibleValues = Array(10).fill(true);\n      cell.possibleValues[0] = false;  // 0 is not a valid value\n    }\n    for (const region of this.getAllRegions()) {\n      let possibleInRegion = Array(10).fill(true);\n      for (const cell of region) {\n        if (cell.value !== null) {\n          possibleInRegion[cell.value] = false;\n        }\n      }\n      for (const cell of region) {\n        bitmaskAndInPlace(cell.possibleValues, possibleInRegion);\n      }\n    }\n  }\n\n  clearImpossibleMarks() {\n    for (const cell of this.getAllCells()) {\n      bitmaskAndInPlace(cell.centerMarks, cell.possibleValues);\n      bitmaskAndInPlace(cell.cornerMarks, cell.possibleValues);\n    }\n  }\n\n  autofillCenterMarks() {\n    for (const cell of this.getAllCells()) {\n      if (cell.value === null\n          && bitmaskCount(cell.centerMarks) === 0\n          && bitmaskCount(cell.possibleValues) <= 3) {\n        cell.centerMarks = cell.possibleValues.slice();\n      }\n    }\n  }\n\n  autofillCornerMarks() {\n    for (const box of this.getAllBoxes()) {\n      // Find out which values are not marked yet in any corner of the\n      // box and in how many cells of the box can each value go.\n      let alreadyMarkedValues = Array(10).fill(false);\n      let possibleCellsForValue = Array(10).fill(0);\n      for (const cell of box) {\n        if (cell.value === null) {\n          bitmaskOrInPlace(alreadyMarkedValues, cell.cornerMarks);\n          for (let value = 1; value <= 9; ++value) {\n            if (cell.possibleValues[value]) {\n              possibleCellsForValue[value] += 1;\n            }\n          }\n        }\n      }\n\n      for (let value = 1; value <= 9; ++value) {\n        if (alreadyMarkedValues[value]\n            || possibleCellsForValue[value] === 0\n            || possibleCellsForValue[value] > 2) {\n          // This value does not need adding corner marks.\n          continue;\n        }\n        for (const cell of box) {\n          if (cell.value === null && cell.possibleValues[value]) {\n            cell.cornerMarks[value] = true;\n          }\n        }\n      }\n    }\n  }\n\n  autofillValuesOnSingleCenterMarks() {\n    let changed = false;\n    for (const cell of this.getAllCells()) {\n      if (cell.value === null && bitmaskCount(cell.possibleValues) === 1) {\n        cell.value = cell.possibleValues.indexOf(true);\n        changed = true;\n      }\n    }\n    return changed;\n  }\n\n  autofillValuesOnSingleCornerMarks() {\n    let changed = false;\n    for (const region of this.getAllBoxes()) {\n      // Find values which can go to single cell only in the given region.\n      let possibleCellsForValue = Array(10).fill(0);\n      let alreadyFilledValues = Array(10).fill(false);\n      let targetCells = Array(10).fill(null);\n      for (const cell of region) {\n        if (cell.value !== null) {\n          alreadyFilledValues[cell.value] = true;\n        } else {\n          for (let value = 1; value <= 9; ++value) {\n            if (cell.possibleValues[value]) {\n              if (++possibleCellsForValue[value] === 1) {\n                targetCells[value] = cell;\n              } else {\n                targetCells[value] = null;\n              }\n            }\n          }\n        }\n      }\n      // Fill cells which are the only candidates for the given value.\n      for (let value = 1; value <= 9; ++value) {\n        if (!alreadyFilledValues[value] && targetCells[value] !== null) {\n          targetCells[value].value = value;\n          changed = true;\n        }\n      }\n    }\n    return changed;\n  }\n}\n\nexport default SudokuModel;\n"],"sourceRoot":""}